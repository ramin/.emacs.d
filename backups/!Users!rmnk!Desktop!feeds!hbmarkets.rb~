# -*- coding: utf-8 -*-
require File.dirname(__FILE__) + '/config.rb'
require File.dirname(__FILE__) + '/models/word.rb'

require 'net/pop' 
require 'net/smtp'
require 'tmail'

lookup = {
  "Craig.Harrison@hbmarkets.com" => {
    "blog_id" => 229, 
    "title" => "HB Markets Daily Newsflash Featuring ",     
    "autopublish" => true
  }
}

mail_server = Net::POP3.new('mail.stockopedia.co.uk') 

mail_server.start('publishing', '7stockopedia7') do |pop| 
   puts "#{mail_server.mails.length} mails waiting" 

   mail_server.mails.each do |m|  
            
    email = TMail::Mail.parse(m.pop)
    
    if lookup.key?(email.from.to_s.strip)
      
      @details = lookup[email.from.to_s.strip]      
      @files = email.grab_files(:path => File.dirname(__FILE__) + "/temp/")
  
      @files.each{ |f| @filepath = f if f.match(".doc") }
      
      unless @filepath.nil? and File.exists?(@filepath)
        
        @feed = UserFeed.find(@details['blog_id'])
        @word = Word.new
        @word.file = File.basename(@filepath);
        # @word.path = "/var/www/feeds"
        @word.to_html
                
        if @word.html_exists?
          body = @word.clean_html("Analysts:", "END â€“")
            
          puts "inserting new email '#{email.subject}'"
          u_entry = UserEntry.new(
                                :user_feed => @feed, 
                                :user_id => @feed.user_id, 
                                :url => "", 
                                :title => @details['title'],
                                :body => body,
                                :status => "pending",
                                :published_at => Time.parse(email.date.to_s).to_formatted_s(:db),
                                :guid => Time.parse(email.date.to_s).to_formatted_s(:db)
                                )
          
          unique_today = u_entry.published_today? # check there is not one already today...
          
          # Tickerize that shizzle
          @tickerized = Stockopedia.tickerize(body)
          u_entry.body = @tickerized['text']
          u_entry.tickers = @tickerized['tickers']
          u_entry.save

          if @details["autopublish"] == true && unique_today == false
            puts "publishing node"
            node = Node.new(
                          :title => u_entry.title + "#{@tickerized['companies']}".split(" ")[0, 20].join(" ").chomp(","), 
                          :body => u_entry.body, 
                          :md5 => Digest::MD5.hexdigest(u_entry.title + DateTime.now.to_s), 
                          :username => @feed.user.username, 
                          :user_id => @feed.user_id, 
                          :last_edited_username => @feed.user.username, 
                          :last_edited_user_id => @feed.user_id,
                          :type => "newswrap",
                          :parent_type => "newswrap",              
                          :commented_at => DateTime.now.to_formatted_s(:db),
                          :created_at => DateTime.now.to_formatted_s(:db),
                          :updated_at => DateTime.now.to_formatted_s(:db)
              )
          
            if node.save               
              puts "node saved"
              # find an image to publish
              unless @feed.image.nil?
                puts "publishing image"
                begin                      
                  images = Stockopedia.publish_image(@feed.image, u_entry.title)
                  node.image = images['key']
                rescue => e
                  puts e
                end    
              end
              
              puts "apply tags and tickers"                  
              
              # add some blog level tags
              # node.apply_terms(@details['tags'], "tags") if @details['tags']
              node.apply_terms(@tickerized['tickers'], "tickers")    
              node.save                    
              u_entry.status = "published"  
              u_entry.save
              puts "finished"                  
            end # node save
          end # autopublish true
        end #word =>html exists
      end # unless filepath nil
      puts email.subject                
      puts "fwd-ing"
      # fwd the email to admin account
      begin
        puts "handling the email"
        Net::SMTP.start( 'mail.stockopedia.co.uk') do |smtp|
          smtp.send_message(email.to_s, 'admin@stockopedia.co.uk', 'admin@stockopedia.co.uk')                          
          smtp.send_message(email.to_s, 'ben@stockopedia.co.uk', 'ben@stockopedia.co.uk')              
        end
      rescue => e
        puts "#{e}"
      end
      m.delete
    end # if lookup key found    
 end # each mail
end # mail server start / end - needs to be a black so we can use the delete method        
